Z[i] <- sum(temp_2)/R
S[i] <- sqrt((sum(temp_2-Z[i])^(2))/(R-1))
}
for(i in 1:H){
for(j in 1:length(lambdas)){
matrix[i,j] <- (S[i])/(Z[i]^(1-lambdas[j]))
}
}
CC <- c()
M_lambda <- c()
de_lambda <- c()
for(i in 1:length(lambdas)){
M_lambda[i] <- sum(matrix[,i])/H
de_lambda[i] <- sqrt(sum(((matrix[,i])-(M_lambda[i]))^2)/(H-1))
CC[i] <- de_lambda[i]/M_lambda[i]
}
CC <- rbind(lambdas,CC)
CC
# Parece que la transformación debe ser elevar al cuadrado sin eliminar outliers ni
# valores extremos
NGSP_SQ <- NGSP^2
adf.test(NGSP_SQ)
autoplot(NGSP_SQ)
# Ahora, si quitamos los valores extremos y outliers de la serie original, la mejor
# transformación es elevar la serie ~ a la -7
NGSP_SR <- NGSP^(-7)
adf.test(NGSP_SR)
autoplot(NGSP_SR)
# Ahora utilizaremos el siguiente comando para ver cuántas
# diferencias son necesarias para volver el proceso a uno estacionario.
ndiffs(NGSP_SQ)
# Aplicamos entonces una primera diferencia a la serie original
DNGSP <- diff(NGSP_SQ)
autoplot(DNGSP)
# Podemos notar que la serie parece ser estacionaria con un punto de equilibrio en 0.
mean(DNGSP)
# Ahora veremos cómo se comportan la FAC y la FACP
DFAC <- acf(DNGSP)
DFACP <- pacf(DNGSP)
FACP
model <- Arima(DNGSP, order=c(1,0,0))
residuals <- residuals(model)
checkresiduals(model)
### TEMPORAL
res_autoarima <- residuals(model)
#########################################################################################################
# Supuesto 1 (media cero)
#########################################################################################################
# Debemos verificar que el valor absoluto del cociente sea menor que dos para decir que no hay evidencia de que
# la media del proceso sea diferente de 0.
media <- mean(res_autoarima)
media
desv <- sqrt(var(res_autoarima))
desv
N <- length(res_autoarima)
p <- 0
d <- 1
q <- 0
cociente <- (sqrt(N-d-p)) * (media/desv)
abs(cociente)
autoplot(DNGSP)
#install.packages("forecast")
library(forecast)
library(tseries)
library(fpp2)
library(ggplot2)
library(fma)
library(expsmooth)
library("nortest")
#package faraway
library(faraway)
# Dataset and Setup
# Primero, importamos la serie de tiempo
datos <- read.csv("Henry_Hub_Natural_Gas_Spot_Price.csv", header = TRUE)
datos <- datos[rev(rownames(datos)),]
NGSP <- ts(datos[,2], start=1997, freq=12)
# Graficamos nuestra serie para obtener una vista previa
autoplot(NGSP)
NGSP <- tsclean(NGSP)
# Graficamos nuestra serie para obtener una vista previa
autoplot(NGSP)
# Propuesta de modelo con auto.arima sale que es ARIMA(0,1,0) (I(1)), o sea caminata aleatoria.
autoarima <- auto.arima(NGSP)
autoarima
################################################################################################
# FAC, FACP y varianza
FAC <- acf(NGSP)
FACP <- pacf(NGSP)
VarNGSP<-var(NGSP)
VarNGSP
# Dickey-Fuller Aumentado para probar estacionariedad. El proceso es no estacionario
adf.test(NGSP)
# Graficamos por año con el objetivo de observar si hay estacionalidad
ggseasonplot(NGSP)
# Variación de la seasonal plot con coordenadas polares. Se puede observar que no es estacional.
ggseasonplot(NGSP, polar = TRUE)
# Es posible que el resultado que nos arroja nsdiffs señale que el proceso no es estacional
nsdiffs(NGSP)
# Con el fin de convertir el proceso en uno estacionario, aplicaremos una transformación
# estabilizadora de varianza. Primero, veremos Box Cox:
expected <- mean(NGSP)
expected
residuals <- residuals(naive(NGSP))
autoplot(NGSP)
autoplot(residuals)
## Box Cox
lambda <- BoxCox.lambda(NGSP)
NGSP_BC <- BoxCox(NGSP, lambda)
# Después de aplicar la transformación estabilizadora de varianza, checamos si ya es estacionario
adf.test(NGSP_BC)
# Ahora probaremos la transformación logarítmica
## Logaritmo
NGSP_LOG <- log(NGSP)
adf.test(NGSP_LOG)
autoplot(NGSP_LOG)
# # Sin aplicar tsclean para quitar outliers, los valores p quedan 0.1607, 0.324 y .276 para la
# # serie normal, aplicando BoxCox y logaritmo
# # Aplicando tsclean quedan 0.2778, 0.3471 y 0.3443
#
# Probaremos otras transformaciones
## Square Root
NGSP_SR <- sqrt(NGSP)
adf.test(NGSP_SR)
autoplot(NGSP_SR)
# Sin tsclean 0.2204, con tsclean 0,3155
#
## Cube Root
NGSP_CR <- (NGSP)^(1/3)
adf.test(NGSP_CR)
autoplot(NGSP_CR)
## One over
NGSP_OO <- 1/NGSP
adf.test(NGSP_OO)
autoplot(NGSP_OO)
# Parece que ninguna logra hacerla estacionaria, por lo que probaremos con la
# metodología que está en el Capítulo 4:
H <- 5
N <- length(NGSP)
n <- 9
R <- (N-n)/H
lambdas <- c(-20,-10,-7,-5,-3.5,-3,-2.5,-2,-1.5,-1,-0.5,0,0.5,1,1.5,2,2.5,3,3.5,7,10,20)
breaks <- c()
breaks[1] <- 0
for(i in 1:H){
breaks[i+1] <- R*i
}
temp <- as.vector(t(NGSP))
temp <- head(temp,length(temp)-n)
matrix <- matrix(rep(0), nrow = H, ncol = length(lambdas))
S <- c()
Z <- c()
for(i in 1:H){
a <- breaks[i]+1
b <- breaks[i+1]
temp_2 <- temp[a:b]
Z[i] <- sum(temp_2)/R
S[i] <- sqrt((sum(temp_2-Z[i])^(2))/(R-1))
}
for(i in 1:H){
for(j in 1:length(lambdas)){
matrix[i,j] <- (S[i])/(Z[i]^(1-lambdas[j]))
}
}
CC <- c()
M_lambda <- c()
de_lambda <- c()
for(i in 1:length(lambdas)){
M_lambda[i] <- sum(matrix[,i])/H
de_lambda[i] <- sqrt(sum(((matrix[,i])-(M_lambda[i]))^2)/(H-1))
CC[i] <- de_lambda[i]/M_lambda[i]
}
CC <- rbind(lambdas,CC)
CC
H <- 5
N <- length(NGSP)
n <- 9
R <- (N-n)/H
#lambdas <- c(-20,-10,-7,-5,-3.5,-3,-2.5,-2,-1.5,-1,-0.5,0,0.5,1,1.5,2,2.5,3,3.5,7,10,20)
lambdas <- c(-9,-8.5,-8,-7.5,-7,-6.5,-6,5.5)
breaks <- c()
breaks[1] <- 0
for(i in 1:H){
breaks[i+1] <- R*i
}
temp <- as.vector(t(NGSP))
temp <- head(temp,length(temp)-n)
matrix <- matrix(rep(0), nrow = H, ncol = length(lambdas))
S <- c()
Z <- c()
for(i in 1:H){
a <- breaks[i]+1
b <- breaks[i+1]
temp_2 <- temp[a:b]
Z[i] <- sum(temp_2)/R
S[i] <- sqrt((sum(temp_2-Z[i])^(2))/(R-1))
}
for(i in 1:H){
for(j in 1:length(lambdas)){
matrix[i,j] <- (S[i])/(Z[i]^(1-lambdas[j]))
}
}
CC <- c()
M_lambda <- c()
de_lambda <- c()
for(i in 1:length(lambdas)){
M_lambda[i] <- sum(matrix[,i])/H
de_lambda[i] <- sqrt(sum(((matrix[,i])-(M_lambda[i]))^2)/(H-1))
CC[i] <- de_lambda[i]/M_lambda[i]
}
CC <- rbind(lambdas,CC)
CC
lambdas <- seq(from=-8.5,to=-7.5,by 0.05)
breaks <- c()
breaks[1] <- 0
for(i in 1:H){
breaks[i+1] <- R*i
}
temp <- as.vector(t(NGSP))
temp <- head(temp,length(temp)-n)
matrix <- matrix(rep(0), nrow = H, ncol = length(lambdas))
S <- c()
Z <- c()
for(i in 1:H){
a <- breaks[i]+1
b <- breaks[i+1]
temp_2 <- temp[a:b]
Z[i] <- sum(temp_2)/R
S[i] <- sqrt((sum(temp_2-Z[i])^(2))/(R-1))
}
for(i in 1:H){
for(j in 1:length(lambdas)){
matrix[i,j] <- (S[i])/(Z[i]^(1-lambdas[j]))
}
}
CC <- c()
M_lambda <- c()
de_lambda <- c()
for(i in 1:length(lambdas)){
M_lambda[i] <- sum(matrix[,i])/H
de_lambda[i] <- sqrt(sum(((matrix[,i])-(M_lambda[i]))^2)/(H-1))
CC[i] <- de_lambda[i]/M_lambda[i]
}
CC <- rbind(lambdas,CC)
CC
lambdas <- seq(from=-8.5,to=-7.5,by =0.05)
breaks <- c()
breaks[1] <- 0
for(i in 1:H){
breaks[i+1] <- R*i
}
temp <- as.vector(t(NGSP))
temp <- head(temp,length(temp)-n)
matrix <- matrix(rep(0), nrow = H, ncol = length(lambdas))
S <- c()
Z <- c()
for(i in 1:H){
a <- breaks[i]+1
b <- breaks[i+1]
temp_2 <- temp[a:b]
Z[i] <- sum(temp_2)/R
S[i] <- sqrt((sum(temp_2-Z[i])^(2))/(R-1))
}
for(i in 1:H){
for(j in 1:length(lambdas)){
matrix[i,j] <- (S[i])/(Z[i]^(1-lambdas[j]))
}
}
CC <- c()
M_lambda <- c()
de_lambda <- c()
for(i in 1:length(lambdas)){
M_lambda[i] <- sum(matrix[,i])/H
de_lambda[i] <- sqrt(sum(((matrix[,i])-(M_lambda[i]))^2)/(H-1))
CC[i] <- de_lambda[i]/M_lambda[i]
}
CC <- rbind(lambdas,CC)
CC
CC[2,]
which.min(CC[2,])
# Ahora, si quitamos los valores extremos y outliers de la serie original, la mejor
# transformación es elevar la serie ~ a la -7 (-8.15)
NGSP_SR <- NGSP^(-8.15)
adf.test(NGSP_SR)
autoplot(NGSP_SR)
# Ahora utilizaremos el siguiente comando para ver cuántas
# diferencias son necesarias para volver el proceso a uno estacionario.
ndiffs(NGSP_SR)
# Aplicamos entonces una primera diferencia a la serie original
DNGSP <- diff(NGSP_SR)
autoplot(DNGSP)
# Podemos notar que la serie parece ser estacionaria con un punto de equilibrio en 0.
mean(DNGSP)
# Ahora veremos cómo se comportan la FAC y la FACP
DFAC <- acf(DNGSP)
DFACP <- pacf(DNGSP)
model <- Arima(DNGSP, order=c(1,0,0))
residuals <- residuals(model)
checkresiduals(model)
# Ahora, si quitamos los valores extremos y outliers de la serie original, la mejor
# transformación es elevar la serie ~ a la -7 (-8.15)
NGSP_SR <- ((NGSP^(-8.15))-1)/-8.15
adf.test(NGSP_SR)
# Ahora, si quitamos los valores extremos y outliers de la serie original, la mejor
# transformación es elevar la serie ~ a la -7 (-8.15)
NGSP_SR <- NGSP^(-8.15)
adf.test(NGSP_SR)
NGSP_SR <- ((NGSP^(-8.15))-1)/-8.15
adf.test(NGSP_SR)
autoplot(NGSP_SR)
model <- Arima(DNGSP, order=c(1,1,0))
residuals <- residuals(model)
checkresiduals(model)
model <- Arima(DNGSP, order=c(,1,0))
model <- Arima(DNGSP, order=c(0,1,0))
residuals <- residuals(model)
checkresiduals(model)
autoplot(NGSP)
model <- Arima(DNGSP, order=c(1,1,0))
residuals <- residuals(model)
checkresiduals(model)
model <- Arima(DNGSP, order=c(1,0,0))
model <- Arima(DNGSP, order=c(,2,1))
model <- Arima(DNGSP, order=c(0,2,1))
residuals <- residuals(model)
checkresiduals(model)
library(forecast)
library(tseries)
library(fpp2)
library(ggplot2)
library(fma)
library(expsmooth)
library("nortest")
#package faraway
library(faraway)
################################################################################################
################################################################################################
################################################################################################
### Identificación del modelo ##################################################################
################################################################################################
################################################################################################
################################################################################################
# Dataset and Setup
# Primero, importamos la serie de tiempo
datos <- read.csv("Henry_Hub_Natural_Gas_Spot_Price.csv", header = TRUE)
datos <- datos[rev(rownames(datos)),]
NGSP <- ts(datos[,2], start=1997, freq=12)
# Graficamos nuestra serie para obtener una vista previa
autoplot(NGSP)
# Propuesta de modelo con auto.arima sale que es ARIMA(0,1,0) (I(1)), o sea caminata aleatoria.
# Eso sale sin usar el comando tsclean(NGSP). Usándolo sale ARIMA(1,1,0)
autoarima <- auto.arima(NGSP)
################################################################################################
# FAC, FACP y varianza
FAC <- acf(NGSP)
FACP <- pacf(NGSP)
VarNGSP<-var(NGSP)
VarNGSP
# Dickey-Fuller Aumentado para probar estacionariedad. El proceso es no estacionario
adf.test(NGSP)
## Box Cox
lambda <- BoxCox.lambda(NGSP)
NGSP_BC <- BoxCox(NGSP, lambda)
# Después de aplicar la transformación estabilizadora de varianza, checamos si ya es estacionario
adf.test(NGSP_BC)
# Ahora probaremos la transformación logarítmica
## Logaritmo
NGSP_LOG <- log(NGSP)
adf.test(NGSP_LOG)
autoplot(NGSP_LOG)
# # Sin aplicar tsclean para quitar outliers, los valores p quedan 0.1607, 0.324 y .276 para la
# # serie normal, aplicando BoxCox y logaritmo
# # Aplicando tsclean quedan 0.2778, 0.3471 y 0.3443
#
# Probaremos otras transformaciones
## Square Root
NGSP_SR <- sqrt(NGSP)
adf.test(NGSP_SR)
autoplot(NGSP_SR)
# Sin tsclean 0.2204, con tsclean 0,3155
#
## Cube Root
NGSP_CR <- (NGSP)^(1/3)
adf.test(NGSP_CR)
autoplot(NGSP_CR)
## One over
NGSP_OO <- 1/NGSP
adf.test(NGSP_OO)
autoplot(NGSP_OO)
# Parece que ninguna logra hacerla estacionaria, por lo que probaremos con la
# metodología que está en el Capítulo 4:
H <- 5
N <- length(NGSP)
n <- 9
R <- (N-n)/H
#lambdas <- c(-20,-10,-7,-5,-3.5,-3,-2.5,-2,-1.5,-1,-0.5,0,0.5,1,1.5,2,2.5,3,3.5,7,10,20)
lambdas <- c(-9,-8.5,-8,-7.5,-7,-6.5,-6,5.5)
lambdas <- seq(from=-8.5,to=-7.5,by =0.05)
breaks <- c()
breaks[1] <- 0
for(i in 1:H){
breaks[i+1] <- R*i
}
temp <- as.vector(t(NGSP))
temp <- head(temp,length(temp)-n)
matrix <- matrix(rep(0), nrow = H, ncol = length(lambdas))
S <- c()
Z <- c()
for(i in 1:H){
a <- breaks[i]+1
b <- breaks[i+1]
temp_2 <- temp[a:b]
Z[i] <- sum(temp_2)/R
S[i] <- sqrt((sum(temp_2-Z[i])^(2))/(R-1))
}
for(i in 1:H){
for(j in 1:length(lambdas)){
matrix[i,j] <- (S[i])/(Z[i]^(1-lambdas[j]))
}
}
CC <- c()
M_lambda <- c()
de_lambda <- c()
for(i in 1:length(lambdas)){
M_lambda[i] <- sum(matrix[,i])/H
de_lambda[i] <- sqrt(sum(((matrix[,i])-(M_lambda[i]))^2)/(H-1))
CC[i] <- de_lambda[i]/M_lambda[i]
}
CC <- rbind(lambdas,CC)
CC
# Ahora utilizaremos el siguiente comando para ver cuántas
# diferencias son necesarias para volver el proceso a uno estacionario.
ndiffs(NGSP_SR)
# Aplicamos entonces una primera diferencia a la serie original
DNGSP <- diff(NGSP_SR)
autoplot(DNGSP)
#### ESTO ES UNA PRUEBA
lambda <- BoxCox.lambda(DNGSP)
NGSP_BC <- BoxCox(DNGSP, lambda)
adf.test(NGSP_BC)
autoplot(NGSP_BC)
autoplot(DNGSP)
#### ESTO ES UNA PRUEBA
# lambda <- BoxCox.lambda(DNGSP)
# NGSP_BC <- BoxCox(DNGSP, lambda)
# adf.test(NGSP_BC)
# autoplot(NGSP_BC)
# mean(DNGSP)
asdf <- tsclean(NGSP)
autoplot(asdf)
asdfdif <- diff(asdf)
autoplot(asdfdif)
autoplot(DNGSP)
autoarima(DGNSP)
auto.arima(DGNSP)
auto.arima(DNGSP)
Indice<-read.csv("IPC.csv")
Indice<-read.csv("IPC (1).csv")
#Lectura de serie IPC
getwd()
Indice<-read.csv(paste0(getwd(),"IPC (1).csv"))
Indice<-read.csv(paste0(getwd(),"/","IPC (1).csv"))
Indice<-read.csv(paste0(getwd(),"/","IPC (1).csv"))
library(fpp2)
library(ggplot2)
library(forecast)
library(fma)
library(expsmooth)
library(tseries)
library("nortest")
write.csv(Indice, file = "serie.csv")
IPC<-ts(Indice, start=1969, freq=12)
AUTOCORR<-acf(IPC)
VarIPC<-var(IPC)
VarIPC
plot(IPC)
adf.test(IPC)
ggseasonplot(IPC)
nsdiffs(IPC)
lambda0<-BoxCox.lambda(IPC)
lambda0
BoxCoxIPC<-BoxCox(IPC,lambda0)
autoplot(BoxCoxIPC)
autoplot(log(IPC))
ggAcf(BoxCoxIPC, lag.max=100)
ggtsdisplay(BoxCoxIPC, lag.max=100)
adf.test(BoxCoxIPC) #Prueba de Dickey Fuller
ggtsdisplay(BoxCoxIPCdiff2, lag.max=200)
BoxCoxIPCdiff1<-diff(BoxCoxIPC, differences=1)
ggtsdisplay(BoxCoxIPCdiff1, lag.max=100)
adf.test(BoxCoxIPCdiff1) #Prueba de Dickey Fuller
#Segunda Diferenciaci?n
BoxCoxIPCdiff2<-diff(BoxCoxIPC, differences=2)
ggtsdisplay(BoxCoxIPCdiff2, lag.max=200)
adf.test(BoxCoxIPCdiff2) #Prueba de Dickey Fuller
Var_BCIPCdiff2<-var(BoxCoxIPCdiff2)
sqrt(Var_BCIPCdiff2)
ggAcf(BoxCoxIPCdiff2, lag.max=100)
ggPacf(BoxCoxIPCdiff2, lag.max=100)
#Tercera Diferenciaci?n
BoxCoxIPCdiff3<-diff(BoxCoxIPC, differences=3)
ggtsdisplay(BoxCoxIPCdiff3, lag.max=100)
adf.test(BoxCoxIPCdiff3) #Prueba de Dickey Fuller
Var_BCIPCdiff3<-var(BoxCoxIPCdiff3)
sqrt(Var_BCIPCdiff3)
#Gr?ficas de la funci?n de autocorrelaci?n y autocorrelaci?n parcial de la
#segunda diferencia
ggtsdisplay(BoxCoxIPCdiff2, lag.max=200)
# Ahora veremos cómo se comportan la FAC y la FACP
DFAC <- acf(DNGSP)
DFACP <- pacf(DNGSP)
ggtsdisplay(BoxCoxIPCdiff2, lag.max=200)
ggtsdisplay(DNGSP, lag.max=200)
