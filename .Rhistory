# Después de aplicar la transformación estabilizadora de varianza, checamos si ya es estacionario
adf.test(NGSP_BC)
pp.test(NGSP_BC)
# Creo que está peor jaja :(
# Ahora probaremos la transformación logarítmica
## Logaritmo
NGSP_LOG <- log(NGSP)
adf.test(NGSP_LOG)
autoplot(NGSP_LOG)
# # Sin aplicar tsclean para quitar outliers, los valores p quedan 0.1607, 0.324 y .276 para la
# # serie normal, aplicando BoxCox y logaritmo
# # Aplicando tsclean quedan 0.2778, 0.3471 y 0.3443
#
# Probaremos otras transformaciones
## Square Root
NGSP_SR <- sqrt(NGSP)
adf.test(NGSP_SR)
autoplot(NGSP_SR)
# Sin tsclean 0.2204, con tsclean 0,3155
#
## Cube Root
NGSP_CR <- (NGSP)^(1/3)
adf.test(NGSP_CR)
autoplot(NGSP_CR)
# Sin tsclean 0.2392, con tsclean 0.3261
## One over
NGSP_OO <- 1/NGSP
adf.test(NGSP_OO)
autoplot(NGSP_OO)
# Parece que ninguna logra hacerla estacionaria, por lo que probaremos con la
# metodología que está en el Capítulo 4:
H <- 5
N <- length(NGSP)
n <- 9
R <- (N-n)/H
#lambdas <- c(-20,-10,-7,-5,-3.5,-3,-2.5,-2,-1.5,-1,-0.5,0,0.5,1,1.5,2,2.5,3,3.5,7,10,20)
lambdas <- c(-9,-8.5,-8,-7.5,-7,-6.5,-6,5.5)
lambdas <- seq(from=-8.5,to=8.5,by =0.1)
breaks <- c()
breaks[1] <- 0
for(i in 1:H){
breaks[i+1] <- R*i
}
temp <- as.vector(t(NGSP))
temp <- head(temp,length(temp)-n)
matrix <- matrix(rep(0), nrow = H, ncol = length(lambdas))
S <- c()
Z <- c()
for(i in 1:H){
a <- breaks[i]+1
b <- breaks[i+1]
temp_2 <- temp[a:b]
Z[i] <- sum(temp_2)/R
S[i] <- sqrt((sum(temp_2-Z[i])^(2))/(R-1))
}
for(i in 1:H){
for(j in 1:length(lambdas)){
matrix[i,j] <- (S[i])/(Z[i]^(1-lambdas[j]))
}
}
CC <- c()
M_lambda <- c()
de_lambda <- c()
for(i in 1:length(lambdas)){
M_lambda[i] <- sum(matrix[,i])/H
de_lambda[i] <- sqrt(sum(((matrix[,i])-(M_lambda[i]))^2)/(H-1))
CC[i] <- de_lambda[i]/M_lambda[i]
}
CC <- rbind(lambdas,CC)
CC
lambda <- CC[1,which.min(CC[2,])]
lambda
# Parece que la transformación debe ser elevar al cuadrado sin eliminar outliers ni
# valores extremos
NGSP <- NGSP^lambda
adf.test(NGSP)
autoplot(NGSP)
# Ahora veremos cómo se comportan la FAC y la FACP
DFAC <- acf(DNGSP)
DFACP <- pacf(DNGSP)
# Aplicamos entonces una primera diferencia a la serie original
DNGSP <- diff(NGSP)
autoplot(DNGSP)
# Ahora veremos cómo se comportan la FAC y la FACP
DFAC <- acf(DNGSP)
DFACP <- pacf(DNGSP)
model <- Arima(NGSP, order=c(0,1,0)) # Prometedor
residuals <- residuals(model)
checkresiduals(model)
media <- mean(res_autoarima)
media
desv <- sqrt(var(res_autoarima))
desv
N <- length(res_autoarima)
p <- 0
d <- 1
q <- 0
cociente <- (sqrt(N-d-p)) * (media/desv)
abs(cociente)
# Como el valor absoluto del conciente es menor que 2, entonces podemos decir que no hay evidencia
# suficiente para afirmar que la media del proceso es distinta de cero.
#########################################################################################################
# Supuesto 2 (varianza constante)
#########################################################################################################
# Observamos de manera visual si la varianza parece ser constante o no
checkresiduals(model)
################# Análisis de residuos ##################
#Residuales
res_autoarima <- residuals(model)
checkresiduals(model)
View(model)
media <- mean(res_autoarima)
media
desv <- sqrt(var(res_autoarima))
desv
N <- length(res_autoarima)
p <- 0
d <- 1
q <- 0
cociente <- (sqrt(N-d-p)) * (media/desv)
abs(cociente)
checkresiduals(model)
LI2 <- -2*desv
LS2 <- 2*desv
qqnorm(res_autoarima)
qqline(res_autoarima)
checkresiduals(autoarima)
shapiro.test(res_autoarima)
lillie.test(x = res_autoarima)
# Se asemejan a lo que habíamos visto antes. Sabemos que puede ser un ARIMA(0,1,0)
# De hecho, con tsclean sale un ARIMA(1,1,0)
# pero intentaremos con un AR(1)
autoplot(NGSP)
model <- Arima(NGSP, order=c(1,1,0)) # Prometedor
residuals <- residuals(model)
checkresiduals(model)
################# Análisis de residuos ##################
#Residuales
res_autoarima <- residuals(model)
checkresiduals(model)
#########################################################################################################
# Supuesto 1 (media cero)
#########################################################################################################
# Debemos verificar que el valor absoluto del cociente sea menor que dos para decir que no hay evidencia de que
# la media del proceso sea diferente de 0.
media <- mean(res_autoarima)
media
desv <- sqrt(var(res_autoarima))
desv
N <- length(res_autoarima)
p <- 0
d <- 1
q <- 0
cociente <- (sqrt(N-d-p)) * (media/desv)
abs(cociente)
LI2 <- -2*desv
LS2 <- 2*desv
qqnorm(res_autoarima)
qqline(res_autoarima)
checkresiduals(autoarima)
shapiro.test(res_autoarima)
lillie.test(x = res_autoarima)
model <- Arima(NGSP, order=c(1,1,0)) # Prometedor
residuals <- residuals(model)
checkresiduals(model)
################# Análisis de residuos ##################
#Residuales
res_autoarima <- residuals(model)
lillie.test(x = res_autoarima)
lillie.test(residuals)
lillie.test(residuals)
# Dataset and Setup
# Primero, importamos la serie de tiempo
datos <- read.csv("Henry_Hub_Natural_Gas_Spot_Price.csv", header = TRUE)
datos <- datos[rev(rownames(datos)),]
# Segundo, quitamos outliers o missing values. CHECAR SI ESTÁ BIEN USAR ESTA FUNCIÓN xd
NGSP <- tsclean(NGSP)
################################################################################################
# FAC, FACP y varianza
FAC <- acf(NGSP)
FACP <- pacf(NGSP)
VarNGSP<-var(NGSP)
VarNGSP
expected <- mean(NGSP)
expected
residuals <- residuals(naive(NGSP))
autoplot(NGSP)
autoplot(residuals)
lambda <- BoxCox.lambda(NGSP)
NGSP_BC <- BoxCox(NGSP, lambda)
NGSP <- NGSP_BC
#install.packages("forecast")
library(forecast)
library(tseries)
library(fpp2)
library(ggplot2)
library(fma)
library(expsmooth)
library("nortest")
#package faraway
library(faraway)
getwd()
#setwd("C:/Users/orteg/OneDrive/Documents/GitHub/AnalisisSeriesTiempo")
################################################################################################
################################################################################################
################################################################################################
### Identificación del modelo ##################################################################
################################################################################################
################################################################################################
################################################################################################
# Dataset and Setup
# Primero, importamos la serie de tiempo
datos <- read.csv("Henry_Hub_Natural_Gas_Spot_Price.csv", header = TRUE)
datos <- datos[rev(rownames(datos)),]
NGSP <- ts(datos[,2], start=1997, freq=12)
# Con esto podemos ver la serie de tiempo
# Segundo, quitamos outliers o missing values. CHECAR SI ESTÁ BIEN USAR ESTA FUNCIÓN xd
NGSP <- tsclean(NGSP)
autoplot(NGSP)
# Propuesta de modelo con auto.arima sale que es ARIMA(0,1,0) (I(1)), o sea caminata aleatoria.
# Eso sale sin usar el comando tsclean(NGSP). Usándolo sale ARIMA(1,1,0)
autoarima <- auto.arima(NGSP)
################################################################################################
# FAC, FACP y varianza
FAC <- acf(NGSP)
FACP <- pacf(NGSP)
VarNGSP<-var(NGSP)
VarNGSP
# Dickey-Fuller Aumentado para probar estacionariedad. El proceso es no estacionario
adf.test(NGSP)
pp.test(NGSP)
# Graficamos por año con el objetivo de observar si hay estacionalidad
ggseasonplot(NGSP)
# Variación de la seasonal plot con coordenadas polares. Se puede observar que no es estacional.
ggseasonplot(NGSP, polar = TRUE)
# Es posible que el resultado que nos arroja nsdiffs señale que el proceso no es estacional
nsdiffs(NGSP)
lambda <- BoxCox.lambda(NGSP)
NGSP_BC <- BoxCox(NGSP, lambda)
# Ahora utilizaremos el siguiente comando para ver cuántas
# diferencias son necesarias para volver el proceso a uno estacionario.
ndiffs(NGSP)
# Aplicamos entonces una primera diferencia a la serie original
DNGSP <- diff(NGSP)
backup <- NGSP
model <- Arima(NGSP, order=c(0,1,0)) # Prometedor
auto.arima(NGSP)
model <- Arima(NGSP, order=c(1,1,0))
residuals <- residuals(model)
checkresiduals(model)
media <- mean(res_autoarima)
media
desv <- sqrt(var(res_autoarima))
desv
N <- length(res_autoarima)
p <- 0
d <- 1
q <- 0
cociente <- (sqrt(N-d-p)) * (media/desv)
abs(cociente)
media <- mean(residuals)
media
desv <- sqrt(var(residuals))
desv
N <- length(residuals)
p <- 0
d <- 1
q <- 0
cociente <- (sqrt(N-d-p)) * (media/desv)
abs(cociente)
LI2 <- -2*desv
LS2 <- 2*desv
qqnorm(res_autoarima)
qqline(res_autoarima)
checkresiduals(autoarima)
shapiro.test(res_autoarima)
lillie.test(x = res_autoarima)
lillie.test(x = residuals)
shapiro.test(residuals)
NGSP <- NGSP_BC
# Ahora utilizaremos el siguiente comando para ver cuántas
# diferencias son necesarias para volver el proceso a uno estacionario.
ndiffs(NGSP)
1,0))
model <- Arima(NGSP, order=c(1,1,0)) # Prometedor
residuals <- residuals(model)
checkresiduals(model)
media <- mean(residuals)
media
desv <- sqrt(var(residuals))
desv
N <- length(residuals)
p <- 0
d <- 1
q <- 0
cociente <- (sqrt(N-d-p)) * (media/desv)
abs(cociente)
# Supuesto 3 (residuos independientes)
# Prueba de Ljung-Box
checkresiduals(model)
LI2 <- -2*desv
LS2 <- 2*desv
qqnorm(residuals)
qqline(residuals)
checkresiduals(model)
shapiro.test(residuals)
lillie.test(x = residuals)
##Ejemplo
library(ggplot2)
## Prueba de Hipotesis H0: siga^2=sigma0^2 Ha: sigma^2 > sigma0^2
n=4
miu=100
sigma=10
i=1
j=1
b=1
ji=c()
x1<-c()
x2<-c()
x1prim=c()
x2prim=c()
vec<-c()
u<-c()
z <- 1
mod <- 2^35
afac <- 2^7 + 1
cinc <- 1
# Generar 1000 valores de la estadistica de prueba
while(length(ji) < 1000){
# Sabemos que tenemos una muestra aleatoria con n=4 de dsitribucion N(100,100)
for(j in 1:(n/2)) {
for(i in 1:2){
z <- (afac*z + cinc) - mod*trunc((afac*z + cinc)/mod)
u[i] <- z/mod
}
#Calculo x1 y x2
x1[j]<-((-2*log(u[1]))^(1/2))*cos(2*pi*u[2])
x2[j]<-((-2*log(u[1]))^(1/2))*sin(2*pi*u[2])
x1prim[j]=miu+(sigma*x1[j])
x2prim[j]=miu+(sigma*x2[j])
}
vec<-c(x1prim,x2prim)
# Generar x barra
xsum=sum(vec)
xbar=xsum/n
# Generar S^2
a=1
sint=c()
for(a in 1:n){
sint[a]=x[a]-xbar
#a=a+1
}
snum=sum(sint)
snum2=snum^2
s2=snum2/(n-1)
#Generar est. prueba
ji[b]=((n-1)*s2)/(sigma^2)
b=b+1
}
ji
vec
df=n-1
ggplot(NULL,aes(x=ji))+
geom_histogram(aes(y=..density..),
binwidth = .1,
colour="black", fill="gray")+
stat_function(fun=dchisq,args=list(df),color="blue",size=1)
hist(ji)
ji
sint
##Ejemplo
library(ggplot2)
##Ejemplo
library(ggplot2)
## Prueba de Hipotesis H0: siga^2=sigma0^2 Ha: sigma^2 > sigma0^2
n=4
miu=100
sigma=10
i=1
j=1
b=1
ji=c()
x1<-c()
x2<-c()
x1prim=c()
x2prim=c()
vec<-c()
u<-c()
z <- 1
mod <- 2^35
afac <- 2^7 + 1
cinc <- 1
# Generar 1000 valores de la estadistica de prueba
while(length(ji) < 1000){
# Sabemos que tenemos una muestra aleatoria con n=4 de dsitribucion N(100,100)
for(j in 1:(n/2)) {
for(i in 1:2){
z <- (afac*z + cinc) - mod*trunc((afac*z + cinc)/mod)
u[i] <- z/mod
}
#Calculo x1 y x2
x1[j]<-((-2*log(u[1]))^(1/2))*cos(2*pi*u[2])
x2[j]<-((-2*log(u[1]))^(1/2))*sin(2*pi*u[2])
x1prim[j]=miu+(sigma*x1[j])
x2prim[j]=miu+(sigma*x2[j])
}
vec<-c(x1prim,x2prim)
# Generar x barra
xsum=sum(vec)
xbar=xsum/n
# Generar S^2
a=1
sint=c()
for(a in 1:n){
sint[a]=x[a]-xbar
#a=a+1
}
snum=sum(sint)
snum2=snum^2
s2=snum2/(n-1)
#Generar est. prueba
ji[b]=((n-1)*s2)/(sigma^2)
b=b+1
}
sint[a]=vec[a]-xbar
##Ejemplo
library(ggplot2)
## Prueba de Hipotesis H0: siga^2=sigma0^2 Ha: sigma^2 > sigma0^2
n=4
miu=100
sigma=10
i=1
j=1
b=1
ji=c()
x1<-c()
x2<-c()
x1prim=c()
x2prim=c()
vec<-c()
u<-c()
z <- 1
mod <- 2^35
afac <- 2^7 + 1
cinc <- 1
# Generar 1000 valores de la estadistica de prueba
while(length(ji) < 1000){
# Sabemos que tenemos una muestra aleatoria con n=4 de dsitribucion N(100,100)
for(j in 1:(n/2)) {
for(i in 1:2){
z <- (afac*z + cinc) - mod*trunc((afac*z + cinc)/mod)
u[i] <- z/mod
}
#Calculo x1 y x2
x1[j]<-((-2*log(u[1]))^(1/2))*cos(2*pi*u[2])
x2[j]<-((-2*log(u[1]))^(1/2))*sin(2*pi*u[2])
x1prim[j]=miu+(sigma*x1[j])
x2prim[j]=miu+(sigma*x2[j])
}
vec<-c(x1prim,x2prim)
# Generar x barra
xsum=sum(vec)
xbar=xsum/n
# Generar S^2
a=1
sint=c()
for(a in 1:n){
sint[a]=vec[a]-xbar
#a=a+1
}
snum=sum(sint)
snum2=snum^2
s2=snum2/(n-1)
#Generar est. prueba
ji[b]=((n-1)*s2)/(sigma^2)
b=b+1
}
ji
vec
df=n-1
hist(ji)
ggplot(NULL,aes(x=ji))+
geom_histogram(aes(y=..density..),
binwidth = .1,
colour="black", fill="gray")+
stat_function(fun=dchisq,args=list(df),color="blue",size=1)
ji
##Ejemplo
library(ggplot2)
## Prueba de Hipotesis H0: siga^2=sigma0^2 Ha: sigma^2 > sigma0^2
n=4
miu=100
sigma=10
i=1
j=1
b=1
ji=c()
x1<-c()
x2<-c()
x1prim=c()
x2prim=c()
vec<-c()
u<-c()
z <- 1
mod <- 2^35
afac <- 2^7 + 1
cinc <- 1
for(i in 1:2){
z <- (afac*z + cinc) - mod*trunc((afac*z + cinc)/mod)
u[i] <- z/mod
}
u
